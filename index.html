<script>
    // ... (Mantén tu firebaseConfig igual) ...

    const myId = 'u-' + Math.floor(Math.random() * 999999);
    let myStream, peer, actualCall, currentFacing = "user";

    async function init(facing = "user") {
        try {
            if(myStream) myStream.getTracks().forEach(t => t.stop());
            myStream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: facing, width: 480 }, 
                audio: true 
            });
            document.getElementById('me').srcObject = myStream;
            if(!peer) startPeer();
        } catch (e) { console.error("Error cámara"); }
    }

    function startPeer() {
        // Usamos el servidor público de PeerJS o el tuyo si lo tienes
        peer = new Peer(myId, {
            host: '0.peerjs.com', // Servidor estándar estable
            port: 443,
            secure: true,
            config: { 'iceServers': [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' }
            ]}
        });

        peer.on('open', id => {
            actualizarEstado('idle');
            // Escuchar cambios en la base de datos para autoconexión
            escucharParejas();
        });

        peer.on('call', call => {
            console.log("Recibiendo llamada...");
            actualCall = call;
            call.answer(myStream);
            call.on('stream', s => {
                document.getElementById('remote').srcObject = s;
                actualizarEstado('busy');
            });
        });
    }

    function actualizarEstado(estado) {
        const userRef = db.ref('online_users/' + myId);
        userRef.set({ id: myId, status: estado, ts: Date.now() });
        userRef.onDisconnect().remove();
    }

    function escucharParejas() {
        // Si alguien nos marca como su objetivo, Firebase puede avisarnos aquí
        // Pero para simplificar, usaremos la lógica del botón Siguiente
    }

    async function buscar() {
        const btn = document.getElementById('btn-next');
        btn.disabled = true;
        btn.innerText = "BUSCANDO...";
        
        document.getElementById('remote').srcObject = null;
        if(actualCall) actualCall.close();
        
        // Nos ponemos en modo espera
        actualizarEstado('searching');

        // Buscamos a alguien que esté 'searching' o 'idle'
        db.ref('online_users').limitToFirst(20).once('value', snapshot => {
            const users = snapshot.val();
            let potentialPartner = null;

            if (users) {
                const candidates = Object.values(users).filter(u => u.id !== myId && u.status !== 'busy');
                if (candidates.length > 0) {
                    // Sincronización: El ID menor llama, el ID mayor espera
                    // Esto evita que ambos llamen al mismo tiempo
                    potentialPartner = candidates[0];
                    
                    if (myId < potentialPartner.id) {
                        console.log("Yo inicio la llamada a: " + potentialPartner.id);
                        llamar(potentialPartner.id);
                    } else {
                        console.log("Espero a que " + potentialPartner.id + " me llame");
                        document.getElementById('status').innerText = "Esperando conexión entrante...";
                    }
                }
            }

            // Si en 5 segundos no hay éxito, volvemos a habilitar
            setTimeout(() => {
                btn.disabled = false;
                btn.innerText = "SIGUIENTE PAREJA ➔";
                if (!document.getElementById('remote').srcObject) {
                    document.getElementById('status').innerText = "Nadie disponible, reintenta.";
                }
            }, 5000);
        });
    }

    function llamar(partnerId) {
        const call = peer.call(partnerId, myStream);
        actualCall = call;
        call.on('stream', s => {
            document.getElementById('remote').srcObject = s;
            actualizarEstado('busy');
            document.getElementById('btn-next').disabled = false;
            document.getElementById('btn-next').innerText = "SIGUIENTE PAREJA ➔";
        });
        
        // Error handling por si el otro cerró justo ahora
        call.on('error', err => {
            console.error(err);
            buscar();
        });
    }
    // ... (mantén el resto de funciones de mute, cam, etc.)
</script>
